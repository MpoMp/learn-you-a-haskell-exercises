MpoMp's Haskell learning cheatsheet

___________
Operators
___________
+ - * /
&& || not
< > <= >= == /=
-- 
{-
 -
 -}
___________


Functions
___________
succ n, min a b, max a b

a `div/quot` b, a `mod/rem` b   (‘quot‘ is integer division truncated toward zero, while the result of ‘div‘ is truncated toward negative infinity. The div function is often the more natural one to use, whereas the quot function corresponds to the machine instruction on modern machines, so it's somewhat more efficient)

a `compare` b                   (returns Ordering)
show a                          (a must be Show, returns string)

If a function is comprised only of special characters, it's considered an infix function by default. If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses.

fromIntegral                (fromIntegral :: (Num b, Integral a) => a -> b)
___________


Flow control
___________
    if x > 100 then x else x*2   
___________


Lists
___________
++                  (concatenation)
:                   (append element)
list !! 1           (get list[1])
minimum, maximum
sum, product
concat [l1,l2]      (flattens list of lists)
< > <= >= == /=     (element-wise comparison)
head                (returns first element)
tail                (returns all but head)
last                (returns last element)
init                (returns all but last)
length
null                (checks if empty)
reverse
take x list         (take x elements from the start)
drop x list         (remove x elements from the start)
x `div` list        (check if list contains x)

cycle list                      (infinite list out of list)
repeat x                        (infinite list out of element)
take x(cycle list) 
take x(repeat a)

length' xs = sum [1 | _ <- xs]  ('_' is kind of a wildcard)

Filtering examples
[x*2 | x <- [1..10]]
[x*2 | x <- [1..10], x*2 >= 12] 
[ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]  
[ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] 
[ [ x | x <- xs, even x ] | xs <- xxs
___________


Ranges
___________
[1..20]
[1,2..20]
[5,10..100]
___________


Tuples
___________
[(1,2),("One",2)]
fst t, snd t                (first and second element)
zip l1 l2                   (element-wise tuple generator, returns tuples in list)
___________


Types
___________
:t x                (shows type of variable/function x)
x :: T              (x has type of T, type annotation)

Int                 (bounded, efficient)
Integer             (not bounded)
Float               (single precision)
Double              (double precision)
Bool
Char
String              (not actual type, is [Char])

Ordering            (can be GT, LT or EQ)

If no type is specified, then a type variable is given. 
Functions using these, are called polymorphic.

removeNonUppercase :: [Char] -> [Char]              (input type -> output type)
removeNonUppercase :: String -> String
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

addThree :: Int -> Int -> Int -> Int                (last arg is return type)
addThree x y z = x + y + z    
___________

Typeclasses
___________
Everything before the => symbol is called a class constraint
The elem function has a type of (Eq a) => a -> [a] -> Bool because it uses == over a list to check whether some value we're looking for is in it.

Eq              (members implement == and /=)
Ord             (members implement all the standard comparing functions such as >, <, >= and <=)
Show            (members can be presented as strings)
Read            (opposite of Show)
Enum            (members are sequentially ordered types)
Bounded         (members have an upper and a lower bound - minBound and maxBound functions, all tuples are part of Bounded if the components are also in it - e.g. maxBound :: (Bool, Int, Char) )

Num
Integral
Floating

___________










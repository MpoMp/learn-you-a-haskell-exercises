MpoMp's Haskell learning cheatsheet

___________
Operators
___________
+ - * /
&& || not
< > <= >= == /=
-- 
{-
 -
 -}
___________


Functions
___________
succ n, min a b, max a b

a `div/quot` b, a `mod/rem` b   (‘quot‘ is integer division truncated toward zero, while the result of ‘div‘ is truncated toward negative infinity. The div function is often the more natural one to use, whereas the quot function corresponds to the machine instruction on modern machines, so it's somewhat more efficient)

a `compare` b                   (returns Ordering)
show a                          (a must be Show, returns string)

--If a function is comprised only of special characters, it's considered an infix function by --default. If we want to examine its type, pass it to another function or call it as a prefix --function, we have to surround it in parentheses.

fromIntegral                (fromIntegral :: (Num b, Integral a) => a -> b)

--Pattern is checked top to bottom.
lucky :: (Integral a) => a -> String  
lucky 7 = "LUCKY NUMBER SEVEN!"  
lucky x = "Sorry, you're out of luck, pal!" 

charName :: Char -> String 
charName 'a' = "Albert"
charName x = "???"

addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) 

-- as pattern
capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x] 


Lambdas are basically anonymous functions that are used because we need some functions only once.
numLongChains :: Int  
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))

takeWhile function. 
It takes a predicate and a list and then goes from the beginning of the list and returns its elements while the predicate holds true. Once an element is found for which the predicate doesn't hold, it stops.

A fold takes a binary function, a starting value and a list to fold up.
    sum' :: (Num a) => [a] -> a  
    sum' xs = foldl (\acc x -> acc + x) 0 xs  
    
Folds can be used to implement any function where you traverse a list once, element by element, and then return something based on that. 
Whenever you want to traverse a list to return something, chances are you want a fold. 
That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.
    
Generally, if you have a function like foo a = bar b a, you can rewrite it as foo = bar b, because of currying.

The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right. 
Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so \acc x -> ...), 
the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so \x acc -> ...). 
Obviously right folds work on infinite lists, whereas left ones don't!

The foldl1 and foldr1 functions assume the first (or last) element of the list to be the starting value and then start the fold with the element next to it.

scanl and scanr are like foldl and foldr, only they report all the intermediate accumulator states in the form of a list. 

$ function, also called function application
sqrt (3 + 4 + 9) or if we use $ we can write it as sqrt $ 3 + 4 + 9 because $ has the lowest precedence of any operator
But apart from getting rid of parentheses, $ means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.
    ghci> map ($ 3) [(4+), (10*), (^2), sqrt]  
    [7.0,30.0,9.0,1.7320508075688772] 

    ______________

Function composition (right associative)
f . g = \x -> f (g x)

sum . replicate 5 . max 6.7 $ 8.9 -- this is right associative, equals the line below
--sum (replicate 5 (max 6.7 8.9))

-- fn x = ceiling (negate (tan (cos (max 50 x))))  
fn = ceiling . negate . tan . cos . max 50  
    
___________


Flow control
___________
if x > 100 then x else x*2   
    
--Guards
bmiTell :: (RealFloat a) => a -> String  
bmiTell bmi  
   | bmi <= 18.5 = "You're underweight, you emo, you!"  
   | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
   | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
   | otherwise   = "You're a whale, congratulations!" 

let bindings are expressions themselves. 
where bindings are just syntactic constructs. 

    case expression of pattern -> result  
                       pattern -> result  
                       pattern -> result  
                       ...  

                       
___________


Lists
___________
++                  (concatenation)
:                   (append element)
list !! 1           (get list[1])
minimum, maximum
sum, product
concat [l1,l2]      (flattens list of lists)
< > <= >= == /=     (element-wise comparison)
head                (returns first element)
tail                (returns all but head)
last                (returns last element)
init                (returns all but last)
length
null                (checks if empty)
reverse
take x list         (take x elements from the start)
drop x list         (remove x elements from the start)
x `div` list        (check if list contains x)

cycle list                      (infinite list out of list)
repeat x                        (infinite list out of element)
take x(cycle list) 
take x(repeat a)

length' xs = sum [1 | _ <- xs]  ('_' is kind of a wildcard)

Filtering examples
[x*2 | x <- [1..10]]
[x*2 | x <- [1..10], x*2 >= 12] 
[ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]  
[ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] 
[ [ x | x <- xs, even x ] | xs <- xxs
___________


Ranges
___________
[1..20]
[1,2..20]
[5,10..100]
___________


Tuples
___________
[(1,2),("One",2)]
fst t, snd t                (first and second element)
zip l1 l2                   (element-wise tuple generator, returns tuples in list)
___________


Types
___________
:t x                (shows type of variable/function x)
x :: T              (x has type of T, type annotation)

Int                 (bounded, efficient)
Integer             (not bounded)
Float               (single precision)
Double              (double precision)
Bool
Char
String              (not actual type, is [Char])

Ordering            (can be GT, LT or EQ)

If no type is specified, then a type variable is given. 
Functions using these, are called polymorphic.

removeNonUppercase :: [Char] -> [Char]              (input type -> output type)
removeNonUppercase :: String -> String
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

addThree :: Int -> Int -> Int -> Int                (last arg is return type)
addThree x y z = x + y + z    
___________

Typeclasses
___________
Everything before the => symbol is called a class constraint
The elem function has a type of (Eq a) => a -> [a] -> Bool because it uses == over a list to check whether some value we're looking for is in it.

Eq              (members implement == and /=)
Ord             (members implement all the standard comparing functions such as >, <, >= and <=)
Show            (members can be presented as strings)
Read            (opposite of Show)
Enum            (members are sequentially ordered types)
Bounded         (members have an upper and a lower bound - minBound and maxBound functions, all tuples are part of Bounded if the components are also in it - e.g. maxBound :: (Bool, Int, Char) )

Num
Integral
Floating

___________










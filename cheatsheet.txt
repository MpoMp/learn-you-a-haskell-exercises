MpoMp's Haskell learning cheatsheet

___________
Operators
___________
+ - * /
&& || not
< > <= >= == /=
-- 
{-
 -
 -}
___________


Functions
___________
succ n, min a b, max a b

a `div/quot` b, a `mod/rem` b   (‘quot‘ is integer division truncated toward zero, while the result of ‘div‘ is truncated toward negative infinity. The div function is often the more natural one to use, whereas the quot function corresponds to the machine instruction on modern machines, so it's somewhat more efficient)

a `compare` b                   (returns Ordering)
show a                          (a must be Show, returns string)

--If a function is comprised only of special characters, it's considered an infix function by --default. If we want to examine its type, pass it to another function or call it as a prefix --function, we have to surround it in parentheses.

fromIntegral                (fromIntegral :: (Num b, Integral a) => a -> b)

--Pattern is checked top to bottom.
lucky :: (Integral a) => a -> String  
lucky 7 = "LUCKY NUMBER SEVEN!"  
lucky x = "Sorry, you're out of luck, pal!" 

charName :: Char -> String 
charName 'a' = "Albert"
charName x = "???"

addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) 

-- as pattern
capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x] 

___________


Flow control
___________
if x > 100 then x else x*2   
    
--Guards
bmiTell :: (RealFloat a) => a -> String  
bmiTell bmi  
   | bmi <= 18.5 = "You're underweight, you emo, you!"  
   | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
   | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
   | otherwise   = "You're a whale, congratulations!" 

let bindings are expressions themselves. 
where bindings are just syntactic constructs. 

    case expression of pattern -> result  
                       pattern -> result  
                       pattern -> result  
                       ...  

                       
___________


Lists
___________
++                  (concatenation)
:                   (append element)
list !! 1           (get list[1])
minimum, maximum
sum, product
concat [l1,l2]      (flattens list of lists)
< > <= >= == /=     (element-wise comparison)
head                (returns first element)
tail                (returns all but head)
last                (returns last element)
init                (returns all but last)
length
null                (checks if empty)
reverse
take x list         (take x elements from the start)
drop x list         (remove x elements from the start)
x `div` list        (check if list contains x)

cycle list                      (infinite list out of list)
repeat x                        (infinite list out of element)
take x(cycle list) 
take x(repeat a)

length' xs = sum [1 | _ <- xs]  ('_' is kind of a wildcard)

Filtering examples
[x*2 | x <- [1..10]]
[x*2 | x <- [1..10], x*2 >= 12] 
[ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]  
[ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] 
[ [ x | x <- xs, even x ] | xs <- xxs
___________


Ranges
___________
[1..20]
[1,2..20]
[5,10..100]
___________


Tuples
___________
[(1,2),("One",2)]
fst t, snd t                (first and second element)
zip l1 l2                   (element-wise tuple generator, returns tuples in list)
___________


Types
___________
:t x                (shows type of variable/function x)
x :: T              (x has type of T, type annotation)

Int                 (bounded, efficient)
Integer             (not bounded)
Float               (single precision)
Double              (double precision)
Bool
Char
String              (not actual type, is [Char])

Ordering            (can be GT, LT or EQ)

If no type is specified, then a type variable is given. 
Functions using these, are called polymorphic.

removeNonUppercase :: [Char] -> [Char]              (input type -> output type)
removeNonUppercase :: String -> String
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]

addThree :: Int -> Int -> Int -> Int                (last arg is return type)
addThree x y z = x + y + z    
___________

Typeclasses
___________
Everything before the => symbol is called a class constraint
The elem function has a type of (Eq a) => a -> [a] -> Bool because it uses == over a list to check whether some value we're looking for is in it.

Eq              (members implement == and /=)
Ord             (members implement all the standard comparing functions such as >, <, >= and <=)
Show            (members can be presented as strings)
Read            (opposite of Show)
Enum            (members are sequentially ordered types)
Bounded         (members have an upper and a lower bound - minBound and maxBound functions, all tuples are part of Bounded if the components are also in it - e.g. maxBound :: (Bool, Int, Char) )

Num
Integral
Floating

___________









